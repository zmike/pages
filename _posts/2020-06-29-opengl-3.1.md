---
published: false
---
## Long Weekend

Not really, but I didn't get around to blogging on Friday because I was working until pretty late on something that's Kind Of A Big Deal.

Not really, but it's probably more interesting than my posts about unhandled ALUs.

## ARB_uniform_buffer_object support
[This extension](https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt) is one of the last remaining items (along with [GL_NV_primitive_restart](https://gitlab.freedesktop.org/mesa/mesa/-/issues/2873), which is likely to be done soon as well, and some fixups for [GLSL-1.40](https://gitlab.freedesktop.org/mesa/mesa/-/issues/2874)) required for OpenGL 3.1 support, so I decided to take a break from fixing corner case piglit tests to try doing something useful.

At a very basic level, this extension provides shaders with the ability to declare a "struct" type uniform containing explicitly-defined members that can be referenced normally. Here's a quick vertex shader example from piglit's `rendering` test from the `arb_uniform_buffer_object` extension tests:
```
#extension GL_ARB_uniform_buffer_object : require

layout(std140) uniform;
uniform ub_pos_size { vec2 pos; float size; };
uniform ub_rot {float rotation; };

void main()
{
   mat2 m;
   m[0][0] = m[1][1] = cos(rotation); 
   m[0][1] = sin(rotation); 
   m[1][0] = -m[0][1]; 
   gl_Position.xy = m * gl_Vertex.xy * vec2(size) + pos;
   gl_Position.zw = vec2(0, 1);
};
```
Seen here, there's two UBOs passed as inputs, and the shader's `main()` function directly references their members to perform a rotation on the passed vertex.

## What does this actually mean?
That was my first question. In essence, what it means is that once `PIPE_SHADER_CAP_INDIRECT_CONST_ADDR` is enabled for the driver, shaders are going to start being compiled that contain instructions to perform UBO loads with offsets, as the "struct" member access is really just loading memory from a buffer at an offset from the base.

There's two types of indexing that need to be handled:
* *constant* - this is like `array[1]`, where the index is explicitly defined
* *dynamic* - this is `array[i]`, where the index has been computed by the shader
This type of indexing applies to both `uniform block indexing`, which determines which UBO is being accessed by the instruction, and `uniform block offset`, which is the precise region in that UBO being accessed.